# JS Contribution Guide

The JS layer provides a mechanism to add scriptability into the Nuclei Engine. The `pkg/js` directory contains the implementation of the JS runtime in Nuclei.

## Introduction

The JS layer is based on [goja](https://github.com/dop251/goja) which is a Pure-Go Javascript Runtime that provides ECMAScript 5.1 execution in a pretty easy and native-go manner. 

The readme mentions its strengths in terms of passing complex data structures and functions between Go and JS (which is also why it is also used in [grafana/k6](https://github.com/grafana/k6)).

Our implementation of JS layer is based around 3 steps - 

1. Library implementation - Write the code for the module in `pkg/js/libs/` directory. Create a new directory like `sftp` or use an existing one.
2. Code generation - Code generation generates Library integration code.
3. Javascript-YAML integration in templates - Integrated javascript functionality in templates allows javascript modules to be ran from a nuclei template.


## Directory structure

The directory structure is divided into a number of sub-directories to better structure the components.

A table listing the directories and their description in the `js` directory is provided below.

| Directory | Description | 
|-----------|-------------|
| `compiler`| `goja` based Compiler implementation. Used by consumers to execute the javascript code importing all helpers and modules |
|`generated`| Generated Golang-Goja interfaces, Javascript Skeleton as well as Markdown documentation from the Libraries defined in `libs` generated by `generator` |
| `generator` | Golang-based code generator to generate the code in `generated/` directory. The `generator/bin` directory contains the code generator |
| `gojs` | Go-js interface layer allowing easy library addition. Isn't relevant for a consumer or developer of the API (Internal) |
| `libs` | Contains the libraries for nuclei grouped by directories. Each directory contains go code to implement a library. Examples are `ssh` which provides SSH functionality, `smb` which provides SMB, etc. |
| `scripts` | Contains additional exported functions that are accessible to the runtime. Contains functions like `dump_json`, `hex_to_ascii`, etc. |

## Adding / Modifying Libraries

### Adding a new library


### Extending an existing library

**Mysql Authenticated Query Execution**

As an example, let's add Mysql arbitrary query execution post authentication to the `mysql` library. The `postgresql` bindings already support this functionality. We can base our implementation on it.

We can add a new method to the `js/libs/mysql/mysql.go` called `ExecuteQuery` which will take a arbitrary `SELECT` query along with MySQL credentials and will execute and return the results as json.

```go
// ExecuteQuery connects to Mysql database using given credentials and database name.
// and executes a query on the db.
func (c *Client) ExecuteQuery(host string, port int, username, password, dbName, query string) (string, error) {}
```

We can copy the code to connect to mysql from the `connect` function above. The code basically just connects to a database using provided credentials.

```go
target := net.JoinHostPort(host, fmt.Sprintf("%d", port))

db, err := sql.Open("mysql", fmt.Sprintf("%v:%v@tcp(%v)/%s",
	url.PathEscape(username),
	url.PathEscape(password),
	target,
	dbName))
if err != nil {
	return "", err
}
defer db.Close()
```

Next, we can run the query and return the results as JSON. The below code uses `db.Query` method to query the DB as done in `postgres` and then unmarshalls the sql rows to JSON using `utils.UnmarshalSQLRows` method.

```go
rows, err := db.Query(query)
if err != nil {
	return "", err
}
resp, err := utils.UnmarshalSQLRows(rows)
if err != nil {
	return "", err
}
return string(resp), nil
```

The entire function code looks like this when assembled together - 

```go
// ExecuteQuery connects to Mysql database using given credentials and database name.
// and executes a query on the db.
func (c *Client) ExecuteQuery(host string, port int, username, password, dbName, query string) (string, error) {
	target := net.JoinHostPort(host, fmt.Sprintf("%d", port))

	db, err := sql.Open("mysql", fmt.Sprintf("%v:%v@tcp(%v)/%s",
		url.PathEscape(username),
		url.PathEscape(password),
		target,
		dbName))
	if err != nil {
		return "", err
	}
	defer db.Close()

	rows, err := db.Query(query)
	if err != nil {
		return "", err
	}
	resp, err := utils.UnmarshalSQLRows(rows)
	if err != nil {
		return "", err
	}
	return string(resp), nil
}
```

An example of calling the above function from javascript - 

```javascript
var dbs = c.ExecuteQuery(Host, 3306, User, Pass, "INFORMATION_SCHEMA", "SHOW DATABASES;");
if (dbs) {
  data = dbs;
}
```

Which results in the following in nuclei 

```bash
[mysql-brute] [javascript] [high] 127.0.0.1 [map[output:[{"Database":"information_schema"},{"Database":"example"}]]]
```

**SMBGhost Exploit**

SMBGhost is a very popular SMB vulnerability in Windows SMB Server implementation which had quite a lot of vulnerable hosts when it was announced.

To implement the SMBGhost vulnerability detection in JS Library for `smb`, we can look for exploits in `Go` (Preferred) or other languages, or discover technical details and attempt to write a POC ourself.

In this case, let's attempt to create the implementation from a python POC for SMBGhost detection from [smb-scanner](https://github.com/gabimarti/SMBScanner/blob/master/smb-scanner.py).

The exploit works by sending a SMB packet to the server and checking if the result contains the indicator for the vulnerability.

We can just the above implementation by defining a new function within `smb` package. Create a new file in `js/libs/smb/smbghost.go` and save it.

```go
// DetectSMBGhost tries to detect SMBGhost vulnerability
// by using SMBv3 compression feature.
func (c *Client) DetectSMBGhost(host string, port int) (bool, error) {}
```

The exploit is contained in `GoGhost.go` file. The code basically builds a pkt and sends it on the network socket. The package detects the vulnerabiliy in the SMB stack.

The truncated `pkt` definition is shown below. Copy and paste this to our newly created `smbghost.go` file.

```go
const (
	# Packet to send and check vuln
    pkt =  "\x00\x00\x00\xc0\xfeSMB@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x00\x00\x00\x00\x00\x00\x00\x00
    ... truncated ...
```


Then we can just implement the sending of this packet and checking if the detection was successful. The cleaned up final `DetectSMBGhost` implementation is provided below.

```go
// DetectSMBGhost tries to detect SMBGhost vulnerability
// by using SMBv3 compression feature.
func (c *Client) DetectSMBGhost(host string, port int) (bool, error) {
	addr := net.JoinHostPort(host, strconv.Itoa(port))
	conn, err := net.DialTimeout("tcp", addr, 5*time.Second)
	if err != nil {
		return false, err

	}
	defer conn.Close()

	conn.Write([]byte(pkt))

	buff := make([]byte, 4)
	nb, _ := conn.Read(buff)
	args, err := structs.StructsUnpack(">I", buff[:nb])
	if err != nil {
		return false, err
	}
	length := args[0].(int)
	data := make([]byte, length)
	_ = conn.SetReadDeadline(time.Now().Add(2 * time.Second))
	n, err := conn.Read(data)
	if err != nil {
		return false, err
	}
	data = data[:n]

	if !bytes.Equal(data[68:70], []byte("\x11\x03")) || !bytes.Equal(data[70:72], []byte("\x02\x00")) {
		return false, nil
	}
	return true, nil
}
```

The implements sends the packet, reads the number of bytes using `structs.StructsUnpack` method and reads the bytes returned, comparing to see if we have a successful detection.

Now we can use this from a template like below - 

```javascript
var m = require("nuclei/libsmb");
var c = m.Client();
c.DetectSMBGhost(Host, 445);
```

Which results in following in nuclei - 

```bash
[smbghost-detection] [javascript] [high] 202.148.44.124:445
[smbghost-detection] [javascript] [high] 222.134.104.66:445
[smbghost-detection] [javascript] [high] 211.165.203.230:445
[smbghost-detection] [javascript] [high] 192.28.213.141:445
[smbghost-detection] [javascript] [high] 22.80.134.82:445
```

## Code generation

The layer uses Code Generation at build time from Golang AST to automate bulk of the Go JS Plugin Interface + JS Skeletons + Markdown code generation tasks when adding a new library or updating an existing one.

## Javascript-YAML Integration


## Tips And Tricks

A collection of tips and tricks are provided to address the common questions users might have while either writing new libraries or using existing ones.

### Go Library Guidelines

1. Keep exported package clean. Do not keep unncessary global exports which the consumer of the API doesn't need to know about. Keep only user-exposed API public.
2. Use timeouts and context cancellation when calling Network related stuff. Also make sure to close your connections or provide a mechanism to the user of the API to do so.
3. Make sure to document all your Public Types and Functions added. The markdown generated document uses the information in comments.
4. Always try to return single types from inside javascript with an error like `(IsRDP, error)` instead of returning multiple values `(name, version string, err error)`. The second one will get converted to an array is much harder for consumers to deal with. Instead, try to return `Structures` which will be accessible natively.


### Javascript Code Guidelines

1. Use `dump_json` stdlib function or `console.log` to provide debug information to the consumer of a template when doing complex stuff.
2. Catch exceptions using `try/catch` blocks and handle errors gracefully, showing useful information. By default, the implementation returns a Go error on a unhandled exception along with stack trace in debug mode.
3. Use `let`/`cost` instead of `var` to declare variables.
4. Keep the global scope clean. The VMs are not shared so do not rely on VM state.
5. Use functions to divide the code and keep the implementation clean. 