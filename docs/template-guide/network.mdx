---
title: "Network"
---

## Network Requests

Nuclei can act as an automatable **Netcat**, allowing users to send bytes across the wire and receive them, while providing matching and extracting capabilities on the response.

Network Requests start with a **network** block which specifies the start of the requests for the template.

```yaml
# Start the requests for the template right here
tcp:
```

### Inputs

First thing in the request is **inputs**. Inputs are the data that will be sent to the server, and optionally any data to read from the server.

At it's most simple, just specify a string, and it will be sent across the network socket.

```yaml
# inputs is the list of inputs to send to the server
inputs: 
  - data: "TEST\r\n"
```

You can also send hex encoded text that will be first decoded and the raw bytes will be sent to the server.

```yaml
inputs:
  - data: "50494e47"
    type: hex
  - data: "\r\n"
```

Helper function expressions can also be defined in input and will be first evaluated and then sent to the server. The last Hex Encoded example can be sent with helper functions this way - 

```yaml
inputs:
  - data: 'hex_decode("50494e47")\r\n'
```

One last thing that can be done with inputs is reading data from the socket. Specifying `read-size` with a non-zero value will do the trick. You can also assign the read data some name, so matching can be done on that part.

```yaml
inputs:
  - read-size: 8
```

Example with reading a number of bytes, and only matching on them.

```yaml
inputs:
  - read-size: 8
    name: prefix
...
matchers:
  - type: word
    part: prefix
    words: 
      - "CAFEBABE"
```

Multiple steps can be chained together in sequence to do network reading / writing.

### Host

The next part of the requests is the **host** to connect to. Dynamic variables can be placed in the path to modify its value on runtime. Variables start with `{{` and end with `}}` and are case-sensitive.

1. **Hostname** - variable is replaced by the hostname provided on command line.

An example name value:

```yaml
host: 
  - "{{Hostname}}"
```

Nuclei can also do TLS connection to the target server. Just add `tls://` as prefix before the **Hostname** and you're good to go.

```yaml
host:
  - "tls://{{Hostname}}"
```

If a port is specified in the host, the user supplied port is ignored and the template port takes precedence.

### Port

Nuclei v2.9.15 adds a new field 'port' that can be specified seperately instead of doing something like

```yaml
 # let's say we are writing a network template for xyz-ssh-exploit
host:
  - "{{Hostname}}
  - "{{Hostname}}:22"
```

In above 'host' example we are sending two network requests i.e
- first request is sent to **port** (if present) in input/target.
- second request is sent to **22** port (i.e default ssh port)

the reason behind doing so is giving users flexibility to run a network template on both default port and non-default port. Suppose a user already knowns that **ssh service** is running on non-default port of 2222 (after doing a port scan with service discovery). In this case users can simply run

```console
$ nuclei -u scanme.sh:2222 -id "xyz-ssh-exploit"
```

and nuclei will use '2222' instead of default port '22' and if user doesnot specifiy any port in input then '22' is used. But this maynot be straightforward to understand and generates warnings in logs (since one request is destined to fail).

Another known issue with this design of writing network templates is request being sent to **unexpected ports**. Ex: a web service might be running on port 8443 and when user runs 

```console
$ nuclei -u scanme.sh:8443 
```

In this case "xyz-ssh-exploit" template will send one request to "scanme.sh:22" and another request to "scanme.sh:8443" which might return unexpected response and eventually error out. This is especially true in case of automations.

Now, this can be avoided while keeping existing functionality by writing network templates in following fashion:

```yaml
 # new xyz-ssh-exploit
host:
  - "{{Hostname}}"
Port: 22
```
In above design functionality to run template on non-standard ports will exist except on default reserved ports of 80,443,8080,8443,8081,53 and even this can be customized by adding new field

```yaml
exclude-ports: 80,443
```
when exclude-ports is used default **reserved ports** list is overwritten.


#### Matchers / Extractor Parts

Valid `part` values supported by **Network** protocol for Matchers / Extractor are - 
    
| Value            | Description                         |
|------------------|-------------------------------------|
| request          | Network Request                     |
| data             | Final Data Read From Network Socket |
| raw / body / all | All Data received from Socket       |

### **Example Network Template**

The final example template file for a `hex` encoded input to detect MongoDB running on servers with working matchers is provided below.

```yaml
id: input-expressions-mongodb-detect

info:
  name: Input Expression MongoDB Detection
  author: pd-team
  severity: info
  reference: https://github.com/orleven/Tentacle

tcp:
  - inputs:
      - data: "{{hex_decode('3a000000a741000000000000d40700000000000061646d696e2e24636d640000000000ffffffff130000001069736d6173746572000100000000')}}"
    host:
      - "{{Hostname}}"
    read-size: 2048
    matchers:
      - type: word
        words:
          - "logicalSessionTimeout"
          - "localTime"
```

More complete examples are provided [here](/template-example/network).