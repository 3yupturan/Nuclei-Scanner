{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://template",
  "$ref": "#/$defs/Template",
  "$defs": {
    "AttackTypeHolder": {
      "properties": {
        "Value": {
          "type": "integer"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "Value"
      ]
    },
    "Classification": {
      "properties": {
        "cve-id": {
          "$ref": "#/$defs/StringOrSlice",
          "title": "cve ids for the template",
          "description": "CVE IDs for the template"
        },
        "cwe-id": {
          "$ref": "#/$defs/StringOrSlice",
          "title": "cwe ids for the template",
          "description": "CWE IDs for the template"
        },
        "cvss-metrics": {
          "type": "string",
          "title": "cvss metrics for the template",
          "description": "CVSS Metrics for the template",
          "examples": [
            "3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
          ]
        },
        "cvss-score": {
          "type": "number",
          "title": "cvss score for the template",
          "description": "CVSS Score for the template",
          "examples": [
            9.8
          ]
        },
        "epss-score": {
          "type": "number",
          "title": "epss score for the template",
          "description": "EPSS Score for the template",
          "examples": [
            0.42509
          ]
        },
        "epss-percentile": {
          "type": "number",
          "title": "epss percentile for the template",
          "description": "EPSS Percentile for the template",
          "examples": [
            0.42509
          ]
        },
        "cpe": {
          "type": "string",
          "title": "cpe for the template",
          "description": "CPE for the template",
          "examples": [
            "cpe:/a:vendor:product:version"
          ]
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Extractor": {
      "properties": {
        "name": {
          "type": "string",
          "title": "name of the extractor",
          "description": "Name of the extractor"
        },
        "type": {
          "$ref": "#/$defs/ExtractorTypeHolder"
        },
        "regex": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "regex to extract from part",
          "description": "Regex to extract from part"
        },
        "group": {
          "type": "integer",
          "title": "group to extract from regex",
          "description": "Group to extract from regex"
        },
        "kval": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "kval pairs to extract from response",
          "description": "Kval pairs to extract from response"
        },
        "json": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "json jq expressions to extract data",
          "description": "JSON JQ expressions to evaluate from response part"
        },
        "xpath": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "html xpath expressions to extract data",
          "description": "XPath allows using xpath expressions to extract items from html response"
        },
        "attribute": {
          "type": "string",
          "title": "optional attribute to extract from xpath",
          "description": "Optional attribute to extract from response XPath"
        },
        "dsl": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "dsl expressions to extract",
          "description": "Optional attribute to extract from response dsl"
        },
        "part": {
          "type": "string",
          "title": "part of response to extract data from",
          "description": "Part of the request response to extract data from"
        },
        "internal": {
          "type": "boolean",
          "title": "mark extracted value for internal variable use",
          "description": "Internal when set to true will allow using the value extracted in the next request for some protocols"
        },
        "case-insensitive": {
          "type": "boolean",
          "title": "use case insensitive extract",
          "description": "use case insensitive extract"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "type"
      ]
    },
    "ExtractorTypeHolder": {
      "properties": {
        "ExtractorType": {
          "type": "integer"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "ExtractorType"
      ]
    },
    "HTTPMethodTypeHolder": {
      "properties": {
        "MethodType": {
          "type": "integer"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "MethodType"
      ]
    },
    "Holder": {
      "type": "string",
      "enum": [
        "info",
        "low",
        "medium",
        "high",
        "critical",
        "unknown"
      ],
      "title": "severity of the template",
      "description": "Seriousness of the implications of the template"
    },
    "Info": {
      "properties": {
        "name": {
          "type": "string",
          "title": "name of the template",
          "description": "Name should be good short summary that identifies what the template does",
          "examples": [
            "Nagios Default Credentials Check",
            "example-template",
            "TeamCity - Authentication Bypass"
          ]
        },
        "author": {
          "oneOf": [
            {
              "type": "string",
              "description": "Author of the template without any special characters\nIt can be a single author or comma-separated multiple authors",
              "examples": [
                "pdteam"
              ]
            },
            {
              "type": "array",
              "description": "Author of the template without any special characters\nIt can be a single author or comma-separated multiple authors",
              "examples": [
                "pdteam,mr.robot"
              ]
            }
          ],
          "title": "author of the template",
          "description": "Author is the author of the template"
        },
        "tags": {
          "oneOf": [
            {
              "type": "string",
              "description": "Tags for the template separated by commas (No spaces)",
              "examples": [
                "cve"
              ]
            },
            {
              "type": "array",
              "description": "Multiple tags for the template separated by commas (No spaces)",
              "examples": [
                "cve,http",
                "http,oast",
                "cve2024,cve"
              ]
            }
          ],
          "title": "tags of the template",
          "description": "Any tags for the template"
        },
        "description": {
          "type": "string",
          "title": "description of the template",
          "description": "Description of the template.\nYou can go in-depth here on what the template actually does.\nExample:\nApache Log4j2 \u003c=2.14.1 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled.",
          "examples": [
            "Bower is a package manager which stores package information in the bower.json file",
            "Example description of the template"
          ]
        },
        "impact": {
          "type": "string",
          "title": "impact of the template",
          "description": "Impact of the template.\nYou can go in-depth here on impact of the template.\nExample:\nSuccessful exploitation of this vulnerability can lead to remote code execution, potentially compromising the affected system.",
          "examples": [
            "Successful exploitation of this vulnerability could allow an attacker to execute arbitrary SQL queries",
            "Impact of the template"
          ]
        },
        "reference": {
          "$ref": "#/$defs/StringOrSlice",
          "type": "array",
          "title": "references for the template",
          "description": "References for the template.\nThis should contain links relevant to the template.\nExample:\nhttps://logging.apache.org/log4j/2.x/security.html\nhttps://nvd.nist.gov/vuln/detail/CVE-2021-44228",
          "examples": [
            "\n\t- https://example.com"
          ]
        },
        "severity": {
          "$ref": "#/$defs/Holder",
          "description": "Severity of the template.\nsupported values: info, low, medium, high, critical, unknown",
          "examples": [
            "info"
          ]
        },
        "metadata": {
          "type": "object",
          "title": "additional metadata for the template",
          "description": "Optional metadata for the template.\nthis could be any useful metadata like Vendor, Product, Version, etc.\nNote - This is autogenerated and updated regularly for templates merged in projectdiscovery/nuclei-templates repository.\nExample:\n```yaml\nVendor: Apache\nProduct: Log4j2\nVersion: \u003c=2.14.1\n```",
          "examples": [
            "\n\tmax-request: 1",
            "\n\tmax-request: 2\n\tvendor: apache\n\tproduct: log4j2"
          ]
        },
        "classification": {
          "$ref": "#/$defs/Classification",
          "type": "object",
          "title": "classification info for the template",
          "description": "Classification contains classification information about the template.\nThis could be any classification information like CWE, CVE, EPSS etc.\nNote - This is autogenerated and updated regularly for CVE templates merged in projectdiscovery/nuclei-templates repository.\nExample:\n```yaml\ncvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H\ncvss-score: 10\ncve-id: CVE-2021-44228\ncwe-id: CWE-20,CWE-917\nepss-score: 0.97453\nepss-percentile: 0.99942\ncpe: cpe:2.3:a:apache:log4j:*:*:*:*:*:*:*:*\n```",
          "examples": [
            "\n\tcvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H\n\tcvss-score: 10\n\tcve-id: CVE-2021-44228",
            "\n\tcwe-id: CWE-20,CWE-917"
          ]
        },
        "remediation": {
          "type": "string",
          "title": "remediation steps for the template",
          "description": "In-depth explanation on how to fix the issues found by the template",
          "examples": [
            "Change the default administrative username and password of Apache ActiveMQ by editing the file jetty-realm.properties"
          ]
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "name",
        "author"
      ],
      "examples": [
        "\n\tname: Example Template\n\tauthor: pdteam\n\tseverity: info\n\tdescription: This is an example template",
        "\n\tname: example-template\n\tauthor: pdteam\n\tseverity: unknown\n\tdescription: Example description of the template\n\timpact: Impact of the template\n\treference: \n\t  - https://example.com\n\tmetadata: \n\t  max-request: 1\n\ttags: http"
      ]
    },
    "Matcher": {
      "properties": {
        "type": {
          "$ref": "#/$defs/MatcherTypeHolder",
          "title": "type of matcher",
          "description": "Type of the matcher"
        },
        "condition": {
          "type": "string",
          "enum": [
            "and",
            "or"
          ],
          "title": "condition between matcher variables",
          "description": "Condition between the matcher variables"
        },
        "part": {
          "type": "string",
          "title": "part of response to match",
          "description": "Part of response to match data from"
        },
        "negative": {
          "type": "boolean",
          "title": "negative specifies if match reversed",
          "description": "Negative specifies if the match should be reversed. It will only match if the condition is not true"
        },
        "name": {
          "type": "string",
          "title": "name of the matcher",
          "description": "Name of the matcher"
        },
        "status": {
          "items": {
            "type": "integer"
          },
          "type": "array",
          "title": "status to match",
          "description": "Status to match for the response"
        },
        "size": {
          "items": {
            "type": "integer"
          },
          "type": "array",
          "title": "acceptable size for response",
          "description": "Size is the acceptable size for the response"
        },
        "words": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "words to match in response",
          "description": " Words contains word patterns required to be present in the response part"
        },
        "regex": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "regex to match in response",
          "description": "Regex contains regex patterns required to be present in the response part"
        },
        "binary": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "binary patterns to match in response",
          "description": "Binary are the binary patterns required to be present in the response part"
        },
        "dsl": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "dsl expressions to match in response",
          "description": "DSL are the dsl expressions that will be evaluated as part of nuclei matching rules"
        },
        "xpath": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "xpath queries to match in response",
          "description": "xpath are the XPath queries that will be evaluated against the response part of nuclei matching rules"
        },
        "encoding": {
          "type": "string",
          "enum": [
            "hex"
          ],
          "title": "encoding for word field",
          "description": "Optional encoding for the word fields"
        },
        "case-insensitive": {
          "type": "boolean",
          "title": "use case insensitive match",
          "description": "use case insensitive match"
        },
        "match-all": {
          "type": "boolean",
          "title": "match all values",
          "description": "match all matcher values ignoring condition"
        },
        "internal": {
          "type": "boolean",
          "title": "hide matcher from output",
          "description": "hide matcher from output"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "type"
      ]
    },
    "MatcherTypeHolder": {
      "properties": {
        "MatcherType": {
          "type": "integer"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "MatcherType"
      ]
    },
    "OrderedMap[string,string]": {
      "properties": {},
      "additionalProperties": false,
      "type": "object"
    },
    "Request": {
      "properties": {
        "matchers": {
          "items": {
            "$ref": "#/$defs/Matcher"
          },
          "type": "array",
          "title": "matchers to run on response",
          "description": "Detection mechanism to identify whether the request was successful by doing pattern matching"
        },
        "extractors": {
          "items": {
            "$ref": "#/$defs/Extractor"
          },
          "type": "array",
          "title": "extractors to run on response",
          "description": "Extractors contains the extraction mechanism for the request to identify and extract parts of the response"
        },
        "matchers-condition": {
          "type": "string",
          "enum": [
            "and",
            "or"
          ],
          "title": "condition between the matchers",
          "description": "Conditions between the matchers"
        },
        "path": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "path(s) for the http request",
          "description": "Path(s) to send http requests to"
        },
        "raw": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "HTTP Requests in Raw Format"
        },
        "id": {
          "type": "string",
          "title": "id for the http request",
          "description": "ID for the HTTP Request"
        },
        "name": {
          "type": "string",
          "title": "name for the http request",
          "description": "Optional name for the HTTP Request"
        },
        "attack": {
          "$ref": "#/$defs/AttackTypeHolder",
          "title": "attack is the payload combination",
          "description": "Attack is the type of payload combinations to perform"
        },
        "method": {
          "$ref": "#/$defs/HTTPMethodTypeHolder",
          "title": "method is the http request method",
          "description": "Method is the HTTP Request Method"
        },
        "body": {
          "type": "string",
          "title": "body is the http request body",
          "description": "Body is an optional parameter which contains HTTP Request body"
        },
        "payloads": {
          "type": "object",
          "title": "payloads for the http request",
          "description": "Payloads contains any payloads for the current request"
        },
        "headers": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object",
          "title": "headers to send with the http request",
          "description": "Headers contains HTTP Headers to send with the request"
        },
        "race_count": {
          "type": "integer",
          "title": "number of times to repeat request in race condition",
          "description": "Number of times to send a request in Race Condition Attack"
        },
        "max-redirects": {
          "type": "integer",
          "title": "maximum number of redirects to follow",
          "description": "Maximum number of redirects that should be followed"
        },
        "pipeline-concurrent-connections": {
          "type": "integer",
          "title": "number of pipelining connections",
          "description": "Number of connections to create during pipelining"
        },
        "pipeline-requests-per-connection": {
          "type": "integer",
          "title": "number of requests to send per pipelining connections",
          "description": "Number of requests to send per connection when pipelining"
        },
        "threads": {
          "type": "integer",
          "title": "threads for sending requests",
          "description": "Threads specifies number of threads to use sending requests. This enables Connection Pooling"
        },
        "max-size": {
          "type": "integer",
          "title": "maximum http response body size",
          "description": "Maximum size of http response body to read in bytes"
        },
        "fuzzing": {
          "items": {
            "$ref": "#/$defs/Rule"
          },
          "type": "array",
          "title": "fuzzin rules for http fuzzing",
          "description": "Fuzzing describes rule schema to fuzz http requests"
        },
        "self-contained": {
          "type": "boolean"
        },
        "signature": {
          "$ref": "#/$defs/SignatureTypeHolder",
          "title": "signature is the http request signature method",
          "description": "Signature is the HTTP Request signature Method"
        },
        "cookie-reuse": {
          "type": "boolean",
          "title": "optional cookie reuse enable",
          "description": "Optional setting that enables cookie reuse"
        },
        "disable-cookie": {
          "type": "boolean",
          "title": "optional disable cookie reuse",
          "description": "Optional setting that disables cookie reuse"
        },
        "read-all": {
          "type": "boolean",
          "title": "force read all body",
          "description": "Enables force reading of entire unsafe http request body"
        },
        "redirects": {
          "type": "boolean",
          "title": "follow http redirects",
          "description": "Specifies whether redirects should be followed by the HTTP Client"
        },
        "host-redirects": {
          "type": "boolean",
          "title": "follow same host http redirects",
          "description": "Specifies whether redirects to the same host should be followed by the HTTP Client"
        },
        "pipeline": {
          "type": "boolean",
          "title": "perform HTTP 1.1 pipelining",
          "description": "Pipeline defines if the attack should be performed with HTTP 1.1 Pipelining"
        },
        "unsafe": {
          "type": "boolean",
          "title": "use rawhttp non-strict-rfc client",
          "description": "Unsafe specifies whether to use rawhttp engine for sending Non RFC-Compliant requests"
        },
        "race": {
          "type": "boolean",
          "title": "perform race-http request coordination attack",
          "description": "Race determines if all the request have to be attempted at the same time (Race Condition)"
        },
        "req-condition": {
          "type": "boolean",
          "title": "preserve request history",
          "description": "Automatically assigns numbers to requests and preserves their history"
        },
        "stop-at-first-match": {
          "type": "boolean",
          "title": "stop at first match",
          "description": "Stop the execution after a match is found"
        },
        "skip-variables-check": {
          "type": "boolean",
          "title": "skip variable checks",
          "description": "Skips the check for unresolved variables in request"
        },
        "iterate-all": {
          "type": "boolean",
          "title": "iterate all the values",
          "description": "Iterates all the values extracted from internal extractors"
        },
        "digest-username": {
          "type": "string",
          "title": "specifies the username for digest authentication",
          "description": "Optional parameter which specifies the username for digest auth"
        },
        "digest-password": {
          "type": "string",
          "title": "specifies the password for digest authentication",
          "description": "Optional parameter which specifies the password for digest auth"
        },
        "disable-path-automerge": {
          "type": "boolean",
          "title": "disable auto merging of path",
          "description": "Disable merging target url path with raw request path"
        },
        "filter": {
          "items": {
            "$ref": "#/$defs/Matcher"
          },
          "type": "array",
          "title": "filter for fuzzing",
          "description": "Filter is matcher-like field to check if fuzzing should be performed on this request or not"
        },
        "filter-condition": {
          "type": "string",
          "enum": [
            "and",
            "or"
          ],
          "title": "condition between the filters",
          "description": "Conditions between the filters"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Rule": {
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "replace",
            "prefix",
            "postfix",
            "infix",
            "replace-regex"
          ],
          "title": "type of rule",
          "description": "Type of fuzzing rule to perform"
        },
        "part": {
          "type": "string",
          "enum": [
            "query",
            "header",
            "path",
            "body",
            "cookie",
            "request"
          ],
          "title": "part of rule",
          "description": "Part of request rule to fuzz"
        },
        "mode": {
          "type": "string",
          "enum": [
            "single",
            "multiple"
          ],
          "title": "mode of rule",
          "description": "Mode of request rule to fuzz"
        },
        "keys": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "keys of parameters to fuzz",
          "description": "Keys of parameters to fuzz"
        },
        "keys-regex": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "keys regex to fuzz",
          "description": "Regex of parameter keys to fuzz"
        },
        "values": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "title": "values regex to fuzz",
          "description": "Regex of parameter values to fuzz"
        },
        "fuzz": {
          "$ref": "#/$defs/SliceOrMapSlice",
          "title": "payloads of fuzz rule",
          "description": "Payloads to perform fuzzing substitutions with"
        },
        "replace-regex": {
          "type": "string",
          "title": "replace regex of rule",
          "description": "Regex for regex-replace rule type"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SignatureTypeHolder": {
      "properties": {
        "Value": {
          "type": "integer"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "Value"
      ]
    },
    "SliceOrMapSlice": {
      "properties": {
        "Value": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "KV": {
          "$ref": "#/$defs/OrderedMap[string,string]"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "Value",
        "KV"
      ]
    },
    "StringOrSlice": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "array"
        }
      ]
    },
    "Template": {
      "anyOf": [
        {
          "required": [
            "id",
            "info",
            "http"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "dns"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "file"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "tcp"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "headless"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "ssl"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "websocket"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "whois"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "code"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "javascript"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "requests"
          ]
        },
        {
          "required": [
            "id",
            "info",
            "network"
          ]
        },
        {
          "required": [
            "workflows"
          ]
        }
      ],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^([a-zA-Z0-9]+[-_])*[a-zA-Z0-9]+$",
          "title": "id of the template",
          "description": "ID is the unique id for the template.\n ### Good IDs \nA good ID uniquely identifies what the requests in the template\nare doing. Let's say you have a template that identifies a git-config\nfile on the webservers, a good name would be `git-config-exposure`. Another\nexample name is `azure-apps-nxdomain-takeover`",
          "examples": [
            "example-id",
            "git-config-exposure",
            "azure-apps-nxdomain-takeover",
            "cve-2021-19520"
          ]
        },
        "info": {
          "$ref": "#/$defs/Info",
          "type": "object",
          "title": "info for the template",
          "description": "Info contains the required metadata information about the template\nIt is meant to provide basic but necessary info like name, author , severity\nalong with many other optional fields like metadata, classification etc\nNote: - \nFor a template to be valid name,author,severity of `info` section must be set"
        },
        "flow": {
          "type": "string",
          "title": "template execution flow in js",
          "description": "Flow describes how multiple request-blocks/protocols should be combined together and executed\nIt is a javascript code where each protocol is a function and all request-blocks are indexed by their corresponding index in request array\nExample: \n flow: http(1) \u0026\u0026 http(2)\n means that second http request will be executed only if first http request is successful (aka matched)",
          "examples": [
            "'flow: http(0) \u0026\u0026 http(1)'",
            "http(1) \u0026\u0026 http(2)",
            " | # example-vhost-enum\n\tssl(); // -\u003e  execute all ssl protocol requests\n\tdns(); // -\u003e  execute all dns protocol requests\n\tfor (let got of template.domains) { // -\u003e  iterate over 'domains' array variable\n\t\tset('vhost', got); // -\u003e  set 'vhost' variable to current domain\n\t\thttp(); // -\u003e  execute all http protocol requests\n\t}\n"
          ]
        },
        "requests": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "http requests to make",
          "description": "HTTP requests to make for the template",
          "deprecated": true
        },
        "http": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "http requests to make",
          "description": "HTTP requests to make for the template"
        },
        "dns": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "dns requests to make",
          "description": "DNS requests to make for the template"
        },
        "file": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "file requests to make",
          "description": "File requests to make for the template"
        },
        "network": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "network requests to make",
          "description": "Network requests to make for the template",
          "deprecated": true
        },
        "tcp": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "network(tcp) requests to make",
          "description": "Network requests to make for the template"
        },
        "headless": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "headless requests to make",
          "description": "Headless requests to make for the template"
        },
        "ssl": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "ssl requests to make",
          "description": "SSL requests to make for the template"
        },
        "websocket": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "websocket requests to make",
          "description": "Websocket requests to make for the template"
        },
        "whois": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "whois requests to make",
          "description": "WHOIS requests to make for the template"
        },
        "code": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "code snippets to make",
          "description": "Code snippets"
        },
        "javascript": {
          "items": {
            "$ref": "#/$defs/Request"
          },
          "type": "array",
          "title": "javascript requests to make",
          "description": "Javascript requests to make for the template"
        },
        "workflows": {
          "items": {
            "$ref": "#/$defs/WorkflowTemplate"
          },
          "type": "array",
          "title": "list of workflows to execute",
          "description": "List of workflows to execute for template"
        },
        "self-contained": {
          "type": "boolean",
          "title": "mark requests as self-contained",
          "description": "Self-contained marks all requests in this template as independent of input which means input/target is not required for execution of template\nbut other variables defined in template need to be explicitly set using -V flag\nDefault value is false\nNote: self-contained templates only run once regardless of how many targets where provided to nuclei\nExample: \n```yaml\nself-contained: true\n```\nFull example template of self-contained is available at https://cloud.projectdiscovery.io/public/aws-app-enum",
          "default": false,
          "examples": [
            true
          ]
        },
        "stop-at-first-match": {
          "type": "boolean",
          "title": "stop at first match",
          "description": "stop-at-first-match stops the execution of template as soon as first match/result was found in a template given that template was sending multiple requests\nthis is required in case of default-login , brute-force and even detection templates where multiple requests are sent from template but we want to exit as soon as first match/result was found\nExample: \n```yaml\nstop-at-first-match: true\n```\nFull example template of stop-at-first-match is available at https://cloud.projectdiscovery.io/public/bitbucket-public-repository",
          "default": false,
          "examples": [
            true
          ]
        },
        "signature": {
          "$ref": "#/$defs/SignatureTypeHolder",
          "title": "signature is the http request signature method",
          "description": "Signature is the HTTP Request signature Method",
          "deprecated": true
        },
        "variables": {
          "type": "object",
          "title": "variables for the http request",
          "description": "Variables are the global variables that once defined here can be used anywhere in the template\nVariables are evaluated in the order they are defined so one variable can be referenced in another variable\nVariables are evaluated before sending every requests so one can reference any variables that are available at runtime and they will be evaluate and used when referenced\nExample: \n```yaml\nvariables:\n  oast: {{interact-sh}}\n  payload: \"{{base64(oast)}}\"\n```\nFull example template of variables is available at https://cloud.projectdiscovery.io/public/screenshot\nNote: -\nThese variables can be overridden by -V flag at runtime if needed",
          "examples": [
            "\n\tdomain: \"{{FQDN}}\"\n\temail: pdteam@{{domain}}",
            "\n\toast: \"{{interact-sh}}\"\n\tpayload: \"{{base64(oast)}}\""
          ]
        },
        "constants": {
          "type": "object",
          "title": "constant for the template",
          "description": "Constants are the global constants that once defined here can be used anywhere in the template\nIt can be used in same way as variables but only difference is that constants cannot be overridden by -V flag at runtime\nExample: \n```yaml\nconstants:\n  exploit: 'x0x0x0x0x0x0x\n```",
          "examples": [
            "\n\texploit: 'x0x0x0x0x0x0x"
          ]
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "id",
        "info"
      ]
    },
    "Variable": {
      "properties": {},
      "additionalProperties": false,
      "type": "object"
    },
    "WorkflowTemplate": {
      "properties": {
        "template": {
          "type": "string",
          "title": "template/directory to execute",
          "description": "Template or directory to execute as part of workflow"
        },
        "tags": {
          "$ref": "#/$defs/StringOrSlice",
          "title": "tags to execute",
          "description": "Tags to run template based on"
        },
        "matchers": {
          "items": {
            "$ref": "#/$defs/Matcher"
          },
          "type": "array",
          "title": "name based template result matchers",
          "description": "Matchers perform name based matching to run subtemplates for a workflow"
        },
        "subtemplates": {
          "items": {
            "$ref": "#/$defs/WorkflowTemplate"
          },
          "type": "array",
          "title": "subtemplate based result matchers",
          "description": "Subtemplates are ran if the template field Template matches"
        }
      },
      "additionalProperties": false,
      "type": "object"
    }
  }
}
